/**
    common library, prefixed to every kernel.
    2014.7.14
*/

#if !defined(__OPENCL_VERSION__)
#define _DEBUG
#pragma once
#endif /* !defined(__OPENCL_VERSION__) */

/* Diagnostic. */
#if defined(_DEBUG) && !defined(__OPENCL_VERSION__)
int printf( const char* format, ... );
void abort( void );
#define KRNL_STR2(v) #v
#define KRNL_STR(v) KRNL_STR2(v)
#define assert(expression) if(!(expression)){ \
        printf("Assertion failed: %s, function %s, file %s, line %d.\n", \
                KRNL_STR(expression),   __func__ ,__FILE__, __LINE__); \
                abort(); }else
#else
#define assert(...)
#endif /* defined(_DEBUG) && !defined(__OPENCL_VERSION__) */

/* Unified typename. */
#if defined(__OPENCL_VERSION__)
#define kbool bool
#define k8s char
#define k8u uchar
#define k16s short
#define k16u ushort
#define k32s int
#define k32u uint
#define k64s long
#define k64u ulong
#else
#define kbool int
#define k8s signed char
#define k8u unsigned char
#define k16s short int
#define k16u unsigned short int
#define k32s long int
#define k32u unsigned long int
#define k64s long long int
#define k64u unsigned long long int
#endif /* defined(__OPENCL_VERSION__) */

/* Unified compile hint. */
#if defined(__OPENCL_VERSION__)
#define kdeclspec(...) __attribute__((__VA_ARGS__))
#define hdeclspec(...)
#else
#define kdeclspec(...)
#if defined(_MSC_VER)
#define hdeclspec(...) __declspec(__VA_ARGS__)
#else
#define hdeclspec(...) __attribute__((__VA_ARGS__))
#endif /* defined(_MSC_VER) */
#endif /* defined(__OPENCL_VERSION__) */

/* Seed struct which holds the current state. */
typedef struct {
    k32u mt[4]; /* State words. */
    k16u mti;   /* State counter: must be within [0,3]. */
} seed_t;

/*
    Timestamp is defined as a 16-bit unsigned int.
    the atomic time unit is 10 milliseconds, thus the max representable timestamp is 10'55"350.
*/
typedef k16u time_t;
#define FROM_SECONDS( sec ) ((time_t)((float)(sec) * 100.0f))
#define FROM_MILLISECONDS( msec ) ((time_t)((float)(msec) / 10.0f))

/* Event queue. */
#define EQ_SIZE (63)
typedef struct {
    time_t time;
    k8u routine;
    k8u snapshot; /* Preserved. */
} event_t;
typedef struct {
    k16u count;
    k16u power_suffice;
    event_t event[EQ_SIZE];
} event_queue_t;

/* Runtime info struct, each thread preserves its own. */
typedef struct kdeclspec( packed ) {
    seed_t seed;
    time_t timestamp;
    event_queue_t eq;
    float* statistic; /* Should be __global__ ? */
    snapshot_t* snapshot;

} rtinfo_t;

/* Declaration Action Priority List (APL) */
void scan_apl( rtinfo_t* rti ); /* Implement is generated by front-end. */

/*
    Event routine entries. Each class module implement its own.
    Each type of event should be assigned to a routine number.
    Given routine number 'routine_entries' select the corresponding function to call.
*/
void routine_entries( rtinfo_t* rti, event_t e );

/* Initialize RNG */
/*** Behaviors of uninitialized RNG is undefined!!! ***/
void init_rng( seed_t* state, k32u seed ) {
    state->mti = 0; /* Reset counter */
    /* Use a LCG to fill state matrix. See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
    state->mt[0] = seed & 0xffffffffUL;
    seed = ( 1812433253UL * ( seed ^ ( seed >> 30 ) ) ) + 1;
    state->mt[1] = seed & 0xffffffffUL;
    seed = ( 1812433253UL * ( seed ^ ( seed >> 30 ) ) ) + 2;
    state->mt[2] = seed & 0xffffffffUL;
    seed = ( 1812433253UL * ( seed ^ ( seed >> 30 ) ) ) + 3;
    state->mt[3] = seed & 0xffffffffUL;
}

/* Generate one IEEE-754 single precision float point within [.0f, 1.0f). */
float rng( seed_t* seed ) {
    k32u y; /* Should be a register. */
    assert( seed->mti < 4 ); /* If not, RNG is uninitialized. */

    /* Concat lower-right and upper-left state bits. */
    y = ( seed->mt[seed->mti] & 0xfffffffeU ) | ( seed->mt[( seed->mti + 1 ) & 3] & 0x00000001U );
    /* Compute next state with the recurring equation. */
    y = seed->mt[seed->mti] = seed->mt[( seed->mti + 2 ) & 3] ^ ( y >> 1 ) ^ ( 0xfa375374U & -( y & 0x1U ) );
    /* Increase the counter */
    seed->mti = ( seed->mti + 1 ) & 3;
    /* Tempering */
    y ^= ( y >> 12 );
    y ^= ( y << 7 ) & 0x33555f00U;
    y ^= ( y << 15 ) & 0xf5f78000U;
    y ^= ( y >> 18 );
    /* Mask to IEEE-754 format [1.0f, 2.0f). */
    y = ( ( y & 0x3fffffffU ) | 0x3f800000U );
    return ( *( float* )&y ) - 1.0f; /* Decrease to [.0f, 1.0f). */
}

/* Enqueue an event into EQ. */
event_t* eq_enqueue( rtinfo_t* rti, time_t trigger, k8u routine, k8u snapshot ) {
    k32u i = ++( rti->eq.count );
    event_t* p = &( rti->eq.event[-1] );

    assert( rti->eq.count <= EQ_SIZE ); /* Full check. */
    assert( rti->timestamp <= trigger ); /* Time won't go back. */

    for( ; i > 1 && p[i >> 1].time > trigger; i >>= 1 )
        p[i] = p[i >> 1];
    p[i] = ( event_t ) { .time = trigger, .routine = routine, .snapshot = snapshot };
    return &p[i];
}

/* Enqueue a power suffice event into EQ. */
void eq_enqueue_ps( rtinfo_t* rti, time_t trigger ) {
    if ( !rti->eq.power_suffice || rti->eq.power_suffice > trigger )
        rti->eq.power_suffice = trigger;
}

/* Execute the top priority. */
void eq_execute( rtinfo_t* rti ) {
    k16u i, child;
    event_t min, last;
    event_t* p = &rti->eq.event[-1];

    assert( rti->eq.count ); /* Empty check. */
    assert( rti->eq.count <= EQ_SIZE ); /* Not zero but negative? */
    assert( rti->timestamp <= p[1].time ); /* Time won't go back. */

    /* When time elapse, trigger a full scanning at APL. */
    if ( rti->timestamp < p[1].time && ( !rti->eq.power_suffice || rti->timestamp < rti->eq.power_suffice ) )
        scan_apl( rti ); /* This may change p[1]. */

    min = p[1];

    if ( !rti->eq.power_suffice || rti->eq.power_suffice >= min.time ) {

        /* Delete from heap. */
        last = p[rti->eq.count--];
        for( i = 1; i << 1 <= rti->eq.count; i = child ) {
            child = i << 1;
            if ( child != rti->eq.count && rti->eq.event[child].time < p[child].time )
                child++;
            if ( last.time > p[child].time )
                p[i] = p[child];
            else
                break;
        }
        p[i] = last;

        /* Now 'min' contains the top priority. Execute it. */
        rti->timestamp = min.time;
        /* TODO: Some preparations? */
        routine_entries( rti, min );
        /* TODO: Some finishing works? */

    } else {
        /* Invoke power suffice routine. */
        rti->timestamp = rti->eq.power_suffice;
        rti->eq.power_suffice = 0;
        /* Power suffices would not make any impact, just a reserved APL scanning. */
    }

}
